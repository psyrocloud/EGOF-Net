# -*- coding: utf-8 -*-
"""
Created on Thu Apr 15 09:47:35 2021

@author: psyrocloud
"""

import torch
import torch.nn.functional as F


def generate_random_mask(bch_mask, samples=4000):
    # filter out repeat elements in uidx and vidx
    '''
    If len(valid(mask))<samples, samples = this count

    Inputs: mask: (b, h, w) in float
    Returns: list of ui, vi s
    '''
    b, h, w = bch_mask.shape
    bch_rand_mask = torch.zeros_like(bch_mask)

    if bch_mask.is_cuda:
        bch_rand_mask = bch_rand_mask.cuda(bch_mask.device)
    mm = bch_mask > 0

    for ib in range(b):
        total_count = torch.sum(mm[ib].float()).int().item()
        if total_count < 2:
            raise ValueError('yp func err: vailid point too few in mask')

        flatten_idx = torch.randint(0, total_count, (1, samples)).flatten()
        flatten_idx = torch.unique(flatten_idx)  # tick out repetitive elements

        if bch_mask.is_cuda:
            flatten_idx = flatten_idx.cuda(bch_mask.device)

        mask_idx = torch.nonzero(mm[ib]).permute(1, 0)
        # random idx
        vidx = mask_idx[0][flatten_idx].long()
        uidx = mask_idx[1][flatten_idx].long()
        # make random mask
        bch_rand_mask[ib][vidx, uidx] = 1.0
        # empty cache in cuda

    return bch_rand_mask


def get_flow_occ(bch_flow0, bch_flow1):
    # inputs (b,2,h,w) tensor
    b, _, h, w = bch_flow0.shape

    # torch.meshgrid is different from numpy.meshgrid
    v0, u0 = torch.meshgrid(torch.linspace(0,h-1,h), torch.linspace(0,w-1,w))
    if bch_flow0.is_cuda:
        uv0 = torch.stack((u0, v0), 0).cuda(bch_flow0.device) # (2, h, w)
        occ = torch.zeros((b, h, w)).cuda(bch_flow0.device)
    else:
        uv0 = torch.stack((u0, v0), 0)
        occ = torch.zeros((b, h, w))

    for ib, (flow0, flow1) in enumerate(zip(bch_flow0, bch_flow1)):
        # view 0 -> 1
        uv1 = torch.round(uv0 + flow0).int()

        # view 1 -> 0
        valid0 = (uv1[0] >= 0) & (uv1[0] < w) & (uv1[1] >= 0) & (uv1[1] < h)  # bool, (h, w)
        uv1[:, ~valid0] = 0

        vec_u1 = uv1.view(2, -1)[0]
        vec_v1 = uv1.view(2, -1)[1]

        query_flow1 = flow1[:, vec_v1.long(), vec_u1.long()].view(2, h, w)
        # cross-check
        back_proj_uv0 = uv1 + query_flow1
        two_mask = torch.abs(uv0 - back_proj_uv0) < 1.0  # default is 1.0

        valid0 = valid0 & two_mask[0] & two_mask[1]
        occ[ib][valid0] = 1

    return occ


def get_bi_flow_occ(bch_flow0, bch_flow1):
    # inputs (b,2,h,w) tensor
    b, _, h, w = bch_flow0.shape

    # torch.meshgrid is different from numpy.meshgrid
    v0, u0 = torch.meshgrid(torch.linspace(0,h-1,h), torch.linspace(0,w-1,w))
    if bch_flow0.is_cuda:
        uv0 = torch.stack((u0, v0), 0).cuda(bch_flow0.device) # (2, h, w)
        occ = torch.zeros((b, h, w)).cuda(bch_flow0.device)   # occ map 0
        occ1 = torch.zeros((b, h, w)).cuda(bch_flow0.device)  # occ map 1
    else:
        uv0 = torch.stack((u0, v0), 0)
        occ = torch.zeros((b, h, w))
        occ1 = torch.zeros((b, h, w))

    for ib, (flow0, flow1) in enumerate(zip(bch_flow0, bch_flow1)):
        # view 0 -> 1
#        uv1 = (uv0 + flow0 + 0.5).int()  # 2, h, w
        uv1 = torch.round(uv0 + flow0).int()

        # view 1 -> 0
        valid0 = (uv1[0] >= 0) & (uv1[0] < w) & (uv1[1] >= 0) & (uv1[1] < h)  # bool, (h, w)
        uv1[:, ~valid0] = 0

        vec_u1 = uv1.view(2, -1)[0]
        vec_v1 = uv1.view(2, -1)[1]

        query_flow1 = flow1[:, vec_v1.long(), vec_u1.long()].view(2, h, w)
        # cross-check
        back_proj_uv0 = uv1 + query_flow1
        two_mask = torch.abs(uv0 - back_proj_uv0) < 1.0  # default is 1.0

        valid0 = valid0 & two_mask[0] & two_mask[1]
        occ[ib][valid0] = 1

        # get occ1
        vec_v1_occ1 = uv1[1, valid0].flatten().long()
        vec_u1_occ1 = uv1[0, valid0].flatten().long()
        occ1[ib][vec_v1_occ1, vec_u1_occ1] = 1

    return occ, occ1  # b, h, w


def generate_corr_moduler_type_i(occ0, flow0, scale=8, gauss_k=10, gauss_c=1):
    # inputs: occ0(b,h,w), flow0(b,2,h,w),
    # NOTE: the occ0 is generated by generate_random_mask() or other hint

    b, h, w = occ0.shape
    if (h/scale)%1 != 0 or (w/scale)%1 != 0:
        raise ValueError('occ0 size must be scale times')
    nh, nw = int(h/scale), int(w/scale)

    occ0 = F.interpolate(occ0.unsqueeze(1), size=(nh, nw), mode='nearest').squeeze(1)
    flow0 = F.interpolate(flow0, size=(nh, nw), mode='nearest') / scale  # both are nearest and they should have corresponding values

    v0, u0 = torch.meshgrid(torch.linspace(0,nh-1,nh), torch.linspace(0,nw-1,nw))
    corr_moduler = torch.zeros((b, nh, nw, nh, nw))

    if occ0.is_cuda:
        corr_moduler = corr_moduler.cuda(occ0.device)
        u0 = u0.cuda(occ0.device)
        v0 = v0.cuda(occ0.device)

    v0 = v0.unsqueeze(0); u0 = u0.unsqueeze(0)
    u1 = flow0[:,0,:,:] + u0  # b, h, w
    v1 = flow0[:,1,:,:] + v0


    # step 1, find valid in occs, paint them 1 in corr_valid
    bmask = occ0 > 0  # b, h, w
    idx = torch.nonzero(bmask)  # idx is [n, 3], 3: b, h, w indices

    u1s = ((u1[idx[:,0], idx[:,1], idx[:,2]]*10).round()*0.1).view(-1,1,1)  # round them to 0.1
    v1s = ((v1[idx[:,0], idx[:,1], idx[:,2]]*10).round()*0.1).view(-1,1,1)  # N, 1, 1

    # corr_moduler[idx] shape is N,h,w
    corr_moduler[idx[:,0], idx[:,1], idx[:,2]] = \
        gauss_k * torch.exp(-((u0.expand(len(idx), nh, nw)-u1s)**2
                             +(v0.expand(len(idx), nh, nw)-v1s)**2
                             ) / (2 * gauss_c**2)
                           )

    # step 3, find invalid in occs, paint corresponding (b, h*w, h, w) [v_b, v_nh*nw, :, :] = 1
    # in this step, reshape the cost to (b, h, w, h*w)  [3d-bool, :, :]
    corr_moduler[~bmask] = 1.0

    return corr_moduler.unsqueeze(3)  # (b, h1, w1, 1, h2, w2)


def generate_corr_moduler_type_ii(occ1, flow1, scale=8, gauss_k=10, gauss_c=1):
    # inputs: occ1 (b, h, w), flow1 (b, 2, h, w)
    corr_moduler = generate_corr_moduler_type_i(occ1, flow1, scale, gauss_k, gauss_c)
    # switch target and reference points
    return corr_moduler.permute(0, 4, 5, 3, 1, 2)  # (b, h1, w1, 1, h2, w2)  NEED TEST


def generate_epipolar_corr_moduler_type_i(bch_vfa, h, w, scale=8, gauss_k=10, gauss_c=1):
    bch, _ = bch_vfa.shape
    a = bch_vfa[:, 0]
    b = bch_vfa[:, 1]
    c = bch_vfa[:, 2]
    d = bch_vfa[:, 3]
    e = bch_vfa[:, 4]
    # a - (bch)

    if (h/scale)%1 != 0 or (w/scale)%1 != 0:
        raise ValueError('h or w size must be scale times')
    nh, nw = int(h/scale), int(w/scale)

#    v0, u0 = torch.meshgrid(  # scale is inside
#            torch.linspace(0,(nh-1)*scale,nh),
#            torch.linspace(0,(nw-1)*scale,nw))

    # grid fix: original_x = scaled_x * scale + scale/2 -0.5
    offset = scale*0.5 - 0.5
    v0, u0 = torch.meshgrid(  # scale is inside
            torch.linspace(0+offset,(nh-1)*scale+offset,nh),
            torch.linspace(0+offset,(nw-1)*scale+offset,nw))

    if bch_vfa.is_cuda:
        u0 = u0.cuda(bch_vfa.device)  # (bch, nh, nw)
        v0 = v0.cuda(bch_vfa.device)

    # epipolar in view 1, a*u' + b*v' + c*u + d*v + e = 0, this is 4D matrix

    # step 1: get cu+dv+e in each u0,v0 in view 0
    cu_dv_e = u0.view(1,nh,nw).expand(bch,nh,nw) * c.view(-1, 1, 1) \
            + v0.view(1,nh,nw).expand(bch,nh,nw) * d.view(-1, 1, 1) \
            + e.view(-1, 1, 1)  # (bch, nh, nw), for every pixel in view 0
    cu_dv_e = cu_dv_e.view(bch, nh, nw, 1, 1).view(bch, nh*nw, 1, 1)

    # step 2: au'+bv'+cu_dv_e
    corr_moduler = a.view(-1,1,1,1) * u0.view(1,1,nh,nw).expand(bch,nh*nw,nh,nw) \
                 + b.view(-1,1,1,1) * v0.view(1,1,nh,nw).expand(bch,nh*nw,nh,nw) \
                 + cu_dv_e

    # step 3: gauss_k*exp(-corr_moduler**2/(a**2+b**2)/(2c**2))
    a2_b2 = (scale**2 * (a**2 + b**2)).view(-1,1,1,1)  # add scale here to balance the distance to nh,nw space
    corr_moduler = gauss_k * torch.exp(-corr_moduler**2 / (a2_b2*(2*gauss_c**2) + 1e-8))

    # step 4: reshape back to (bch, nh, nw, nh, nw)
    corr_moduler = corr_moduler.view(bch, nh, nw, nh, nw)

    return corr_moduler.unsqueeze(3) # (b, h1, w1, 1, h2, w2)  NEED TEST


def generate_epipolar_corr_moduler_type_ii(bch_vfa, h, w, scale=8, gauss_k=10, gauss_c=1):
    bch, _ = bch_vfa.shape
    inverse_bch_vfa = bch_vfa[:, [2,3,0,1,4]]
    corr_moduler = generate_epipolar_corr_moduler_type_i(
            inverse_bch_vfa, h, w, scale=scale, gauss_k=gauss_k, gauss_c=gauss_c)
    return corr_moduler.permute(0, 4, 5, 3, 1, 2)  # (b, h1, w1, 1, h2, w2)


def generate_epipolar_corr_moduler_type_i_noaffine(bch_F, h, w, scale=8, gauss_k=10, gauss_c=1):
    bch, _, _ = bch_F.shape

    if (h/scale)%1 != 0 or (w/scale)%1 != 0:
        raise ValueError('h or w size must be scale times')
    nh, nw = int(h/scale), int(w/scale)

    # grid fix: original_x = scaled_x * scale + scale/2 -0.5
    offset = scale*0.5 - 0.5
    v0, u0 = torch.meshgrid(  # scale is inside
            torch.linspace(0+offset,(nh-1)*scale+offset,nh),
            torch.linspace(0+offset,(nw-1)*scale+offset,nw))
    _1s = torch.ones(1,1,nh*nw)

    if bch_F.is_cuda:
        u0 = u0.cuda(bch_F.device)  # (bch, nh, nw)
        v0 = v0.cuda(bch_F.device)
        _1s = _1s.cuda(bch_F.device)

    # epipolar in view 1, a*u' + b*v' + c*u + d*v + e = 0, this is 4D matrix

    u0_v0_1 = torch.cat((u0.reshape(1,1,nh*nw), v0.reshape(1,1,nh*nw), _1s), dim=1).expand(bch,3,nh*nw)
    epline1s = torch.matmul(bch_F, u0_v0_1)  # bch, 3, nh*nw

    a = epline1s[:, 0, :].view(bch, nh*nw, 1, 1)
    b = epline1s[:, 1, :].view(bch, nh*nw, 1, 1)
    c = epline1s[:, 2, :].view(bch, nh*nw, 1, 1)

    # step 1: get cu+dv+e in each u0,v0 in view 0
#    cu_dv_e = u0.view(1,nh,nw).expand(bch,nh,nw) * c.view(-1, 1, 1) \
#            + v0.view(1,nh,nw).expand(bch,nh,nw) * d.view(-1, 1, 1) \
#            + e.view(-1, 1, 1)  # (bch, nh, nw), for every pixel in view 0
#    cu_dv_e = cu_dv_e.view(bch, nh, nw, 1, 1).view(bch, nh*nw, 1, 1)

    # step 2: au'+bv'+cu_dv_e
#    corr_moduler = a.view(-1,1,1,1) * u0.view(1,1,nh,nw).expand(bch,nh*nw,nh,nw) \
#                 + b.view(-1,1,1,1) * v0.view(1,1,nh,nw).expand(bch,nh*nw,nh,nw) \
#                 + cu_dv_e
    corr_moduler = a * u0.view(1,1,nh,nw).expand(bch,nh*nw,nh,nw) \
                 + b * v0.view(1,1,nh,nw).expand(bch,nh*nw,nh,nw) \
                 + c

    # step 3: gauss_k*exp(-corr_moduler**2/(a**2+b**2)/(2c**2))
    a2_b2 = (scale**2 * (a**2 + b**2))  # add scale here to balance the distance to nh,nw space
    corr_moduler = gauss_k * torch.exp(-corr_moduler**2 / (a2_b2*(2*gauss_c**2) + 1e-8))

    # step 4: reshape back to (bch, nh, nw, nh, nw)
    corr_moduler = corr_moduler.view(bch, nh, nw, nh, nw)

    return corr_moduler.unsqueeze(3) # (b, h1, w1, 1, h2, w2)  NEED TEST


def generate_epipolar_corr_moduler_type_ii_noaffine(bch_F, h, w, scale=8, gauss_k=10, gauss_c=1):
    bch_F_T = torch.transpose(bch_F, 1, 2)
    corr_moduler = generate_epipolar_corr_moduler_type_i_noaffine(
            bch_F_T, h, w, scale=scale, gauss_k=gauss_k, gauss_c=gauss_c)
    return corr_moduler.permute(0, 4, 5, 3, 1, 2)  # (b, h1, w1, 1, h2, w2)


def generate_corr_moduler_type_i_a(occ0, flow0, scale=8, gauss_k=10, gauss_c=1):
    # inputs: occ0(b,h,w), flow0(b,2,h,w),
    # NOTE: the occ0 is generated by generate_random_mask() or other hint
    '''
    This version shifts the downsampled u0,v0
    '''
    b, h, w = occ0.shape
    if (h/scale)%1 != 0 or (w/scale)%1 != 0:
        raise ValueError('occ0 size must be scale times')
    nh, nw = int(h/scale), int(w/scale)

    # step 0, prepare
    corr_moduler = torch.zeros((b, nh, nw, nh, nw))  # final output this
    flow0 = occ0.unsqueeze(1) * flow0 # filter out non-valid ones, b, 2, h, w

    # step 1, downsample
    occ0 = F.interpolate(occ0.unsqueeze(1), size=(nh, nw), mode='area')  # b, 1, nh, nw
    flow0 = F.interpolate(flow0, size=(nh, nw), mode='area') / scale / (occ0 + 1e-8)  # b, 2, nh, nw with u,v in nh,nw space

    # step 2, get (u1 v1) in view 1
    v0, u0 = torch.meshgrid(  # scale is inside
            torch.linspace(0,nh-1,nh),
            torch.linspace(0,nw-1,nw))  # (h, w)

    if occ0.is_cuda:
        corr_moduler = corr_moduler.cuda(occ0.device)
        u0 = u0.cuda(occ0.device)
        v0 = v0.cuda(occ0.device)

    u1 = flow0[:,0,:,:] + u0.unsqueeze(0)  # b, h, w, by broadcast
    v1 = flow0[:,1,:,:] + v0.unsqueeze(0)

    # step 3, find valid in occs, paint them 1 in corr_valid
    bmask = occ0.squeeze(1) > 0  # b, h, w
    idx = torch.nonzero(bmask)  # idx is [n, 3], 3: b, h, w indices

    # step 4, calculate distance from true corresponding position
    u1s = u1[idx[:,0], idx[:,1], idx[:,2]].view(-1,1,1)
    v1s = v1[idx[:,0], idx[:,1], idx[:,2]].view(-1,1,1)  # N, 1, 1

    # corr_moduler[idx] shape is N,h,w
    corr_moduler[idx[:,0], idx[:,1], idx[:,2]] = \
        gauss_k * torch.exp(-((u0.expand(len(idx), nh, nw)-u1s)**2
                             +(v0.expand(len(idx), nh, nw)-v1s)**2
                             ) / (2 * gauss_c**2))

    # step 5, find invalid in occs, paint corresponding (b, h*w, h, w) [v_b, v_nh*nw, :, :] = 1
    # in this step, reshape the cost to (b, h, w, h*w)  [3d-bool, :, :]
    corr_moduler[~bmask] = 1.0
    return corr_moduler.unsqueeze(3)  # (b, h1, w1, 1, h2, w2)


def generate_corr_moduler_type_ii_a(occ1, flow1, scale=8, gauss_k=10, gauss_c=1):
    # inputs: occ1 (b, h, w), flow1 (b, 2, h, w)
    corr_moduler = generate_corr_moduler_type_i_a(occ1, flow1, scale, gauss_k, gauss_c)
    # switch target and reference points
    return corr_moduler.permute(0, 4, 5, 3, 1, 2)  # (b, h1, w1, 1, h2, w2)  NEED TEST



